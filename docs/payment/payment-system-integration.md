# üè¶ ÊîØ‰ªòÁ≥ªÁªüÈõÜÊàêÊû∂ÊûÑÊñπÊ°à

## üìã ÊñáÊ°£Ê¶ÇËø∞

Êú¨ÊñáÊ°£ËØ¶ÁªÜÊèèËø∞‰∫ÜÈ°πÁõÆÁöÑÊîØ‰ªòÁ≥ªÁªüÈõÜÊàêÊû∂ÊûÑÔºåÈááÁî®Ëß£ËÄ¶ËÆæËÆ°ÊîØÊåÅÂ§öÊîØ‰ªòÊèê‰æõÂïÜÔºåÁ°Æ‰øùAPIÁâàÊú¨Á®≥ÂÆöÊÄßÂíå‰ºÅ‰∏öÁ∫ßÂÆâÂÖ®ÂêàËßÑ„ÄÇ

**ÂÖ≥ËÅîÊñáÊ°£Ôºö**
- [FirebaseËÆ§ËØÅÈõÜÊàê](./firebase-auth-integration.md) - Áî®Êà∑ËÆ§ËØÅÂíåÊï∞ÊçÆÁÆ°ÁêÜ
- [Á≥ªÁªüÊû∂ÊûÑËÆæËÆ°](./system-architecture.md) - Êï¥‰ΩìÁ≥ªÁªüÊû∂ÊûÑ
- [ÂÆûÊñΩË∑ØÁ∫øÂõæ](./implementation-roadmap.md) - È°πÁõÆÂÆûÊñΩËÆ°Âàí

---

## üéØ ËÆæËÆ°ÂéüÂàô

### 1. Ëß£ËÄ¶Êû∂ÊûÑËÆæËÆ°
Êú¨ÊñπÊ°àÈááÁî®**ÊîØ‰ªòÊèê‰æõÂïÜÊó†ÂÖ≥**ÁöÑÊû∂ÊûÑËÆæËÆ°ÔºåÁ°Æ‰øùÔºö
- **Â§öÊîØ‰ªòÊñπÂºèÊîØÊåÅ**ÔºöStripe„ÄÅPayPalÁ≠âÔºåstripe ‰∏∫Á¨¨‰∏Ä‰ºòÂÖà
- **Êèê‰æõÂïÜÂàáÊç¢**ÔºöÊó†ÈúÄ‰øÆÊîπ‰∏öÂä°ÈÄªËæëÂç≥ÂèØÂàáÊç¢ÊîØ‰ªòÊèê‰æõÂïÜ
- **Ê∏êËøõÂºèÈõÜÊàê**ÔºöÊîØÊåÅÈÄêÊ≠•Ê∑ªÂä†Êñ∞ÁöÑÊîØ‰ªòÊñπÂºè
- **ÊïÖÈöúÈöîÁ¶ª**ÔºöÂçï‰∏™ÊîØ‰ªòÊèê‰æõÂïÜÊïÖÈöú‰∏çÂΩ±ÂìçÊï¥‰ΩìÁ≥ªÁªü

### 2. APIÁâàÊú¨Á®≥ÂÆöÊÄß
- **Âõ∫ÂÆöÁâàÊú¨ÈîÅÂÆö**Ôºö‰ΩøÁî® Stripe API `2025-06-30.basil` ÁâàÊú¨
- **ÂêëÂêéÂÖºÂÆπÂ±Ç**ÔºöÊîØÊåÅAPIÁâàÊú¨ÂçáÁ∫ßÁöÑÂÖºÂÆπÂ§ÑÁêÜ
- **ÁâàÊú¨È™åËØÅ**ÔºöÂêØÂä®Êó∂È™åËØÅAPIÁâàÊú¨ÂÖºÂÆπÊÄß
- **Ê∏êËøõÂçáÁ∫ß**ÔºöÊîØÊåÅËìùÁªøÈÉ®ÁΩ≤ÂíåÁÅ∞Â∫¶ÂèëÂ∏É

### 3. ÂÆâÂÖ®‰ºòÂÖàÂéüÂàô
- **PCI DSSÂêàËßÑ**ÔºöÊª°Ë∂≥ÊîØ‰ªòÂç°Ë°å‰∏öÊï∞ÊçÆÂÆâÂÖ®Ê†áÂáÜ
- **Êï∞ÊçÆÂä†ÂØÜ**ÔºöÊïèÊÑüÊï∞ÊçÆÁ´ØÂà∞Á´ØÂä†ÂØÜÂ≠òÂÇ®
- **ÂÆ°ËÆ°ËøΩË∏™**ÔºöÂÆåÊï¥ÁöÑÊîØ‰ªòÊìç‰ΩúÂÆ°ËÆ°Êó•Âøó
- **ÊùÉÈôêÊéßÂà∂**ÔºöÂü∫‰∫éËßíËâ≤ÁöÑÊîØ‰ªòÊùÉÈôêÁÆ°ÁêÜ

### 4. ÂèåÈáçAPIË∑ØÁî±Êû∂ÊûÑ
Êú¨È°πÁõÆÈááÁî®ÂèåÈáçAPIË∑ØÁî±ÁªìÊûÑÔºåÂàÜÂà´ÊúçÂä°‰∫é‰∏çÂêåÁöÑ‰∏öÂä°ÈúÄÊ±ÇÔºö

#### 4.1 ÂõΩÈôÖÂåñAPIË∑ØÁî± (`[locale]/api/`)
**Ë∑ØÂæÑÊ†ºÂºè**Ôºö`/{locale}/api/payments/create-intent`
- **ÈÄÇÁî®Âú∫ÊôØ**ÔºöÈúÄË¶ÅÂ§öËØ≠Ë®ÄÊîØÊåÅÁöÑ‰∏öÂä°ÂäüËÉΩ
- **ÊîØ‰ªòÁõ∏ÂÖ≥API**ÔºöÊîØ‰ªòÊÑèÂõæÂàõÂª∫„ÄÅËÆ¢ÈòÖÁÆ°ÁêÜ„ÄÅË¥¶ÂçïÈó®Êà∑Á≠â
- **Áî®Êà∑ÁïåÈù¢API**ÔºöÈúÄË¶ÅÊ†πÊçÆÁî®Êà∑ËØ≠Ë®ÄÁéØÂ¢ÉËøîÂõûÊú¨Âú∞ÂåñÂÜÖÂÆπÁöÑÊé•Âè£
- **Âä®ÊÄÅË∑ØÁî±**ÔºöÊ†πÊçÆÂΩìÂâçËØ≠Ë®ÄÁéØÂ¢ÉËá™Âä®Ë∑ØÁî±Âà∞ÂØπÂ∫îÁöÑÂ§ÑÁêÜÂô®

**ÊäÄÊúØ‰ºòÂäø**Ôºö
- **Â§öËØ≠Ë®ÄÊîØÊåÅ**ÔºöËá™Âä®Â§ÑÁêÜ‰∏çÂêåËØ≠Ë®ÄÁéØÂ¢É‰∏ãÁöÑ‰∏öÂä°ÈÄªËæë
- **Êú¨Âú∞ÂåñÂìçÂ∫î**ÔºöÈîôËØØÊ∂àÊÅØ„ÄÅÁä∂ÊÄÅÊèèËø∞Á≠âËá™Âä®Êú¨Âú∞Âåñ
- **SEOÂèãÂ•Ω**ÔºöÊîØÊåÅÂ§öËØ≠Ë®ÄURLÁªìÊûÑÔºåÊèêÂçáÂõΩÈôÖÂåñSEOÊïàÊûú
- **Áî®Êà∑‰ΩìÈ™å**ÔºöÁ°Æ‰øùÊîØ‰ªòÊµÅÁ®ãÂú®ÊâÄÊúâÊîØÊåÅËØ≠Ë®Ä‰∏ãÁöÑ‰∏ÄËá¥ÊÄß

#### 4.2 ÂÖ®Â±ÄAPIË∑ØÁî± (`api/`)
**Ë∑ØÂæÑÊ†ºÂºè**Ôºö`/api/contact` Êàñ `/api/system/health`
- **ÈÄÇÁî®Âú∫ÊôØ**ÔºöËØ≠Ë®ÄÊó†ÂÖ≥ÁöÑÁ≥ªÁªüÁ∫ßÂäüËÉΩ
- **Á≥ªÁªüÁõëÊéß**ÔºöÂÅ•Â∫∑Ê£ÄÊü•„ÄÅÊÄßËÉΩÁõëÊéß„ÄÅÊó•ÂøóÊî∂ÈõÜÁ≠â
- **Á¨¨‰∏âÊñπÈõÜÊàê**ÔºöWebhookÊé•Êî∂„ÄÅÂ§ñÈÉ®ÊúçÂä°ÂõûË∞ÉÁ≠â
- **ÁÆ°ÁêÜÂäüËÉΩ**ÔºöÁ≥ªÁªüÈÖçÁΩÆ„ÄÅÁºìÂ≠òÁÆ°ÁêÜ„ÄÅÊï∞ÊçÆÂêåÊ≠•Á≠â

**ÊäÄÊúØ‰ºòÂäø**Ôºö
- **ÊÄßËÉΩ‰ºòÂåñ**ÔºöÈÅøÂÖç‰∏çÂøÖË¶ÅÁöÑÂõΩÈôÖÂåñÂ§ÑÁêÜÂºÄÈîÄ
- **ÁÆÄÂåñÁª¥Êä§**ÔºöÁ≥ªÁªüÁ∫ßAPIÊó†ÈúÄËÄÉËôëÂ§öËØ≠Ë®ÄÂ§çÊùÇÊÄß
- **Ê†áÂáÜÂåñÊé•Âè£**Ôºö‰∏∫Á¨¨‰∏âÊñπÊúçÂä°Êèê‰æõÁªü‰∏ÄÁöÑÊé•Âè£ËßÑËåÉ
- **ÂÆâÂÖ®ÈöîÁ¶ª**ÔºöÂ∞ÜÁ≥ªÁªüÁ∫ßÂäüËÉΩ‰∏éÁî®Êà∑Á∫ßÂäüËÉΩÂàÜÁ¶ª

#### 4.3 Êû∂ÊûÑÂÜ≥Á≠ñÁöÑ‰∏öÂä°‰ª∑ÂÄº

**ÂºÄÂèëÊïàÁéáÊèêÂçá**Ôºö
- ÂºÄÂèëËÄÖÂèØ‰ª•Ê†πÊçÆÂäüËÉΩÁâπÊÄßÈÄâÊã©ÂêàÈÄÇÁöÑË∑ØÁî±ÁªìÊûÑ
- ÂáèÂ∞ëÂõΩÈôÖÂåñÁõ∏ÂÖ≥ÁöÑÈáçÂ§ç‰ª£Á†ÅÂíåÈÖçÁΩÆ
- ÁÆÄÂåñAPIÊµãËØïÂíåË∞ÉËØïÊµÅÁ®ã

**Á≥ªÁªüÂèØÁª¥Êä§ÊÄß**Ôºö
- Ê∏ÖÊô∞ÁöÑËÅåË¥£ÂàÜÁ¶ªÔºå‰æø‰∫éÂõ¢ÈòüÂçè‰ΩúÂºÄÂèë
- Áã¨Á´ãÁöÑÈÉ®ÁΩ≤ÂíåÊâ©Â±ïÁ≠ñÁï•
- Èôç‰ΩéÁ≥ªÁªüÂ§çÊùÇÂ∫¶ÂíåËÄ¶ÂêàÂ∫¶

**Áî®Êà∑‰ΩìÈ™å‰ºòÂåñ**Ôºö
- ÊîØ‰ªòÊµÅÁ®ãÁöÑÂÆåÊï¥ÂõΩÈôÖÂåñÊîØÊåÅ
- Êõ¥Âø´ÁöÑÁ≥ªÁªüÁ∫ßAPIÂìçÂ∫îÈÄüÂ∫¶
- ‰∏ÄËá¥ÁöÑÂ§öËØ≠Ë®ÄÁî®Êà∑ÁïåÈù¢

**ÊäÄÊúØÂÄ∫Âä°ÊéßÂà∂**Ôºö
- ÈÅøÂÖçÂú®Á≥ªÁªüÁ∫ßAPI‰∏≠ÂºïÂÖ•‰∏çÂøÖË¶ÅÁöÑÂõΩÈôÖÂåñ‰æùËµñ
- ‰∏∫Êú™Êù•ÁöÑÂæÆÊúçÂä°ÊãÜÂàÜÊèê‰æõÊ∏ÖÊô∞ÁöÑËæπÁïå
- ÊîØÊåÅÊ∏êËøõÂºèÁöÑÊû∂ÊûÑÊºîËøõ

---

## üèóÔ∏è Á≥ªÁªüÊû∂ÊûÑ

### Ê†∏ÂøÉÊû∂ÊûÑÂàÜÂ±Ç
```mermaid
graph TB
    A[ÂâçÁ´ØÊîØ‰ªòÁªÑ‰ª∂] --> B[ÊîØ‰ªòÊúçÂä°ÊäΩË±°Â±Ç]
    B --> C[ÊîØ‰ªòÊèê‰æõÂïÜÈÄÇÈÖçÂô®]
    C --> D[StripeÈÄÇÈÖçÂô®]
    C --> E[PayPalÈÄÇÈÖçÂô®]
    C --> F[ÂÖ∂‰ªñÊîØ‰ªòÈÄÇÈÖçÂô®]

    G[WebhookÂ§ÑÁêÜÂô®] --> H[ÊîØ‰ªòÁä∂ÊÄÅÂêåÊ≠•]
    H --> I[FirebaseÁî®Êà∑Êï∞ÊçÆ]
    H --> J[‰∫§ÊòìËÆ∞ÂΩïÂ≠òÂÇ®]

    K[ÊîØ‰ªòÂÆâÂÖ®Â±Ç] --> L[PCI DSSÂêàËßÑ]
    K --> M[Êï∞ÊçÆÂä†ÂØÜ]
    K --> N[ÂÆ°ËÆ°Êó•Âøó]
```

### ÁõÆÂΩïÁªìÊûÑËÆæËÆ°
```
src/
‚îú‚îÄ‚îÄ libs/
‚îÇ   ‚îú‚îÄ‚îÄ payments/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment-service.ts      # Áªü‰∏ÄÊîØ‰ªòÊúçÂä°
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment-types.ts        # ÊîØ‰ªòÁ±ªÂûãÂÆö‰πâ
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ payment-errors.ts       # ÊîØ‰ªòÈîôËØØÂ§ÑÁêÜ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ providers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base-provider.ts        # ÊîØ‰ªòÊèê‰æõÂïÜÂü∫Á±ª
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stripe/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stripe-provider.ts  # StripeÈÄÇÈÖçÂô®
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stripe-client.ts    # StripeÂÆ¢Êà∑Á´Ø
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stripe-webhooks.ts  # Stripe Webhook
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stripe-types.ts     # StripeÁ±ªÂûãÂÆö‰πâ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ paypal/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ paypal-provider.ts  # PayPalÈÄÇÈÖçÂô®
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ wechat/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ wechat-provider.ts  # ÂæÆ‰ø°ÊîØ‰ªòÈÄÇÈÖçÂô®
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ storage/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transaction-store.ts    # ‰∫§ÊòìÊï∞ÊçÆÂ≠òÂÇ®
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ payment-cache.ts        # ÊîØ‰ªòÁºìÂ≠ò
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ payment-encryption.ts   # ÊîØ‰ªòÊï∞ÊçÆÂä†ÂØÜ
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ pci-compliance.ts       # PCI DSSÂêàËßÑ
‚îÇ   ‚îî‚îÄ‚îÄ firebase/
‚îÇ       ‚îî‚îÄ‚îÄ user-payment-sync.ts        # Áî®Êà∑ÊîØ‰ªòÊï∞ÊçÆÂêåÊ≠•
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ [locale]/
‚îÇ       ‚îî‚îÄ‚îÄ api/
‚îÇ           ‚îú‚îÄ‚îÄ payments/
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ create-intent/route.ts      # ÂàõÂª∫ÊîØ‰ªòÊÑèÂõæ
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ confirm-payment/route.ts    # Á°ÆËÆ§ÊîØ‰ªò
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ cancel-payment/route.ts     # ÂèñÊ∂àÊîØ‰ªò
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ payment-methods/route.ts    # ÊîØ‰ªòÊñπÂºèÁÆ°ÁêÜ
‚îÇ           ‚îú‚îÄ‚îÄ subscriptions/
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ create/route.ts             # ÂàõÂª∫ËÆ¢ÈòÖ
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ update/route.ts             # Êõ¥Êñ∞ËÆ¢ÈòÖ
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ cancel/route.ts             # ÂèñÊ∂àËÆ¢ÈòÖ
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ billing-portal/route.ts     # Ë¥¶ÂçïÈó®Êà∑
‚îÇ           ‚îî‚îÄ‚îÄ webhooks/
‚îÇ               ‚îú‚îÄ‚îÄ stripe/route.ts             # Stripe Webhook
‚îÇ               ‚îú‚îÄ‚îÄ paypal/route.ts             # PayPal Webhook
‚îÇ               ‚îî‚îÄ‚îÄ webhook-validator.ts        # WebhookÈ™åËØÅ
‚îî‚îÄ‚îÄ components/
    ‚îî‚îÄ‚îÄ payments/
        ‚îú‚îÄ‚îÄ PaymentForm.tsx                     # ÊîØ‰ªòË°®Âçï
        ‚îú‚îÄ‚îÄ PaymentMethodSelector.tsx          # ÊîØ‰ªòÊñπÂºèÈÄâÊã©
        ‚îú‚îÄ‚îÄ SubscriptionManager.tsx            # ËÆ¢ÈòÖÁÆ°ÁêÜ
        ‚îú‚îÄ‚îÄ PaymentHistory.tsx                 # ÊîØ‰ªòÂéÜÂè≤
        ‚îî‚îÄ‚îÄ BillingPortal.tsx                  # Ë¥¶ÂçïÈó®Êà∑
```

---

## üîß Ê†∏ÂøÉÂÆûÁé∞

### 1. ÊîØ‰ªòÊèê‰æõÂïÜÊäΩË±°Êé•Âè£
```typescript
// src/libs/payments/core/payment-types.ts
export type PaymentProvider = {
  readonly name: string;
  readonly version: string;

  // ÂÆ¢Êà∑ÁÆ°ÁêÜ
  createCustomer: (user: UserProfile) => Promise<PaymentCustomer>;
  updateCustomer: (customerId: string, data: Partial<CustomerData>) => Promise<PaymentCustomer>;
  deleteCustomer: (customerId: string) => Promise<void>;

  // ÊîØ‰ªòÂ§ÑÁêÜ
  createPaymentIntent: (request: PaymentIntentRequest) => Promise<PaymentIntent>;
  confirmPayment: (paymentId: string, paymentMethod: string) => Promise<PaymentResult>;
  cancelPayment: (paymentId: string) => Promise<PaymentResult>;

  // ËÆ¢ÈòÖÁÆ°ÁêÜ
  createSubscription: (request: SubscriptionRequest) => Promise<Subscription>;
  updateSubscription: (subscriptionId: string, updates: SubscriptionUpdate) => Promise<Subscription>;
  cancelSubscription: (subscriptionId: string) => Promise<Subscription>;

  // WebhookÂ§ÑÁêÜ
  validateWebhook: (payload: string, signature: string) => Promise<WebhookEvent>;
  processWebhook: (event: WebhookEvent) => Promise<WebhookResult>;
};

export type PaymentIntentRequest = {
  amount: number;
  currency: string;
  customerId: string;
  description?: string;
  metadata?: Record<string, string>;
  paymentMethodTypes?: string[];
  captureMethod?: 'automatic' | 'manual';
};

export type PaymentIntent = {
  id: string;
  clientSecret: string;
  status: PaymentStatus;
  amount: number;
  currency: string;
  customerId: string;
  createdAt: Date;
  metadata?: Record<string, any>;
};

export type PaymentStatus
  = | 'requires_payment_method'
    | 'requires_confirmation'
    | 'requires_action'
    | 'processing'
    | 'succeeded'
    | 'canceled'
    | 'failed';

export type SubscriptionRequest = {
  customerId: string;
  priceId: string;
  quantity?: number;
  trialPeriodDays?: number;
  metadata?: Record<string, string>;
};

export type WebhookEvent = {
  id: string;
  type: string;
  data: any;
  created: Date;
  provider: string;
};
```

### 2. Stripe Êèê‰æõÂïÜÂÆûÁé∞
```typescript
// src/libs/payments/providers/stripe/stripe-provider.ts
import Stripe from 'stripe';
import { Env } from '@/libs/Env';
import { PaymentIntent, PaymentIntentRequest, PaymentProvider } from '../../core/payment-types';

export class StripePaymentProvider implements PaymentProvider {
  readonly name = 'stripe';
  readonly version = '2025-06-30.basil';

  private stripe: Stripe;

  constructor() {
    this.stripe = new Stripe(Env.STRIPE_SECRET_KEY, {
      apiVersion: '2025-06-30.basil',
      typescript: true,
    });
  }

  async createCustomer(user: UserProfile): Promise<PaymentCustomer> {
    const customer = await this.stripe.customers.create({
      email: user.email,
      name: user.displayName,
      metadata: {
        firebaseUid: user.uid,
        source: 'firebase_sync',
        createdAt: new Date().toISOString()
      }
    });

    return {
      id: customer.id,
      email: customer.email!,
      name: customer.name!,
      provider: 'stripe',
      metadata: customer.metadata
    };
  }

  async createPaymentIntent(request: PaymentIntentRequest): Promise<PaymentIntent> {
    const paymentIntent = await this.stripe.paymentIntents.create({
      amount: request.amount,
      currency: request.currency,
      customer: request.customerId,
      description: request.description,
      metadata: request.metadata,
      payment_method_types: request.paymentMethodTypes || ['card'],
      capture_method: request.captureMethod || 'automatic',
      // ÂÆâÂÖ®ËÆæÁΩÆ
      setup_future_usage: 'off_session', // ÊîØÊåÅÂêéÁª≠ÊîØ‰ªò
      confirmation_method: 'manual',
      confirm: false
    });

    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret!,
      status: this.mapStripeStatus(paymentIntent.status),
      amount: paymentIntent.amount,
      currency: paymentIntent.currency,
      customerId: paymentIntent.customer as string,
      createdAt: new Date(paymentIntent.created * 1000),
      metadata: paymentIntent.metadata
    };
  }

  async validateWebhook(payload: string, signature: string): Promise<WebhookEvent> {
    try {
      const event = this.stripe.webhooks.constructEvent(
        payload,
        signature,
        Env.STRIPE_WEBHOOK_SECRET
      );

      return {
        id: event.id,
        type: event.type,
        data: event.data,
        created: new Date(event.created * 1000),
        provider: 'stripe'
      };
    } catch (error) {
      throw new WebhookValidationError('Stripe webhook validation failed', error);
    }
  }

  async processWebhook(event: WebhookEvent): Promise<WebhookResult> {
    switch (event.type) {
      case 'payment_intent.succeeded':
        return await this.handlePaymentSuccess(event.data.object);

      case 'payment_intent.payment_failed':
        return await this.handlePaymentFailure(event.data.object);

      case 'customer.subscription.created':
      case 'customer.subscription.updated':
        return await this.handleSubscriptionUpdate(event.data.object);

      case 'customer.subscription.deleted':
        return await this.handleSubscriptionCancellation(event.data.object);

      case 'invoice.payment_succeeded':
        return await this.handleInvoicePayment(event.data.object);

      default:
        return {
          processed: false,
          message: `Unhandled event type: ${event.type}`
        };
    }
  }

  private mapStripeStatus(stripeStatus: string): PaymentStatus {
    const statusMap: Record<string, PaymentStatus> = {
      requires_payment_method: 'requires_payment_method',
      requires_confirmation: 'requires_confirmation',
      requires_action: 'requires_action',
      processing: 'processing',
      succeeded: 'succeeded',
      canceled: 'canceled'
    };

    return statusMap[stripeStatus] || 'failed';
  }
}
```

### 3. Áªü‰∏ÄÊîØ‰ªòÊúçÂä°
```typescript
import { PayPalPaymentProvider } from '../providers/paypal/paypal-provider';
import { StripePaymentProvider } from '../providers/stripe/stripe-provider';
import { PaymentEncryption } from '../security/payment-encryption';
import { TransactionStore } from '../storage/transaction-store';
// src/libs/payments/core/payment-service.ts
import { PaymentProvider } from './payment-types';

export class PaymentService {
  private providers: Map<string, PaymentProvider> = new Map();
  private defaultProvider: string = 'stripe';
  private transactionStore: TransactionStore;
  private encryption: PaymentEncryption;

  constructor() {
    // Ê≥®ÂÜåÊîØ‰ªòÊèê‰æõÂïÜ
    this.registerProvider(new StripePaymentProvider());
    this.registerProvider(new PayPalPaymentProvider());

    this.transactionStore = new TransactionStore();
    this.encryption = new PaymentEncryption();
  }

  private registerProvider(provider: PaymentProvider): void {
    this.providers.set(provider.name, provider);
  }

  async createPaymentIntent(
    request: PaymentIntentRequest,
    providerName?: string
  ): Promise<PaymentIntent> {
    const provider = this.getProvider(providerName);

    try {
      // 1. ÂàõÂª∫ÊîØ‰ªòÊÑèÂõæ
      const paymentIntent = await provider.createPaymentIntent(request);

      // 2. Â≠òÂÇ®‰∫§ÊòìËÆ∞ÂΩï
      await this.transactionStore.createTransaction({
        id: paymentIntent.id,
        type: 'payment',
        status: paymentIntent.status,
        amount: paymentIntent.amount,
        currency: paymentIntent.currency,
        customerId: paymentIntent.customerId,
        provider: provider.name,
        metadata: paymentIntent.metadata,
        createdAt: paymentIntent.createdAt
      });

      // 3. ËÆ∞ÂΩïÂÆ°ËÆ°Êó•Âøó
      await this.auditLogger.log({
        type: 'PAYMENT_INTENT_CREATED',
        userId: request.customerId,
        details: {
          paymentId: paymentIntent.id,
          amount: paymentIntent.amount,
          currency: paymentIntent.currency,
          provider: provider.name
        },
        severity: 'info'
      });

      return paymentIntent;
    } catch (error) {
      await this.handlePaymentError(error, request, provider.name);
      throw error;
    }
  }

  async createSubscription(
    userId: string,
    planId: string,
    providerName?: string
  ): Promise<Subscription> {
    const provider = this.getProvider(providerName);

    // 1. Ëé∑ÂèñÊàñÂàõÂª∫ÂÆ¢Êà∑
    const user = await this.getUserProfile(userId);
    const customerId = await this.ensureCustomerExists(user, provider);

    // 2. ÂàõÂª∫ËÆ¢ÈòÖ
    const subscription = await provider.createSubscription({
      customerId,
      priceId: planId,
      metadata: {
        firebaseUid: userId,
        source: 'web_app'
      }
    });

    // 3. ÂêåÊ≠•Âà∞Firebase
    await this.syncSubscriptionToFirebase(userId, subscription);

    return subscription;
  }

  async processWebhook(
    providerName: string,
    payload: string,
    signature: string
  ): Promise<WebhookResult> {
    const provider = this.getProvider(providerName);

    try {
      // 1. È™åËØÅWebhook
      const event = await provider.validateWebhook(payload, signature);

      // 2. Ê£ÄÊü•ÈáçÂ§çÂ§ÑÁêÜ
      const isDuplicate = await this.transactionStore.isWebhookProcessed(event.id);
      if (isDuplicate) {
        return { processed: true, message: 'Webhook already processed' };
      }

      // 3. Â§ÑÁêÜ‰∫ã‰ª∂
      const result = await provider.processWebhook(event);

      // 4. Ê†áËÆ∞‰∏∫Â∑≤Â§ÑÁêÜ
      await this.transactionStore.markWebhookProcessed(event.id);

      // 5. ËÆ∞ÂΩïÂÆ°ËÆ°Êó•Âøó
      await this.auditLogger.log({
        type: 'WEBHOOK_PROCESSED',
        details: {
          eventId: event.id,
          eventType: event.type,
          provider: providerName,
          result: result.processed
        },
        severity: 'info'
      });

      return result;
    } catch (error) {
      await this.handleWebhookError(error, providerName, payload);
      throw error;
    }
  }

  private getProvider(providerName?: string): PaymentProvider {
    const name = providerName || this.defaultProvider;
    const provider = this.providers.get(name);

    if (!provider) {
      throw new PaymentProviderError(`Payment provider '${name}' not found`);
    }

    return provider;
  }

  private async ensureCustomerExists(
    user: UserProfile,
    provider: PaymentProvider
  ): Promise<string> {
    // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ÊúâËØ•Êèê‰æõÂïÜÁöÑÂÆ¢Êà∑ID
    const existingCustomerId = user.paymentProviders?.[provider.name]?.customerId;

    if (existingCustomerId) {
      return existingCustomerId;
    }

    // ÂàõÂª∫Êñ∞ÂÆ¢Êà∑
    const customer = await provider.createCustomer(user);

    // Êõ¥Êñ∞FirebaseÁî®Êà∑ËÆ∞ÂΩï
    await this.updateUserPaymentProvider(user.uid, provider.name, {
      customerId: customer.id,
      createdAt: new Date(),
      status: 'active'
    });

    return customer.id;
  }
}

// ÂØºÂá∫Âçï‰æã
export const paymentService = new PaymentService();
```

### 4. APIË∑ØÁî±ÂÆûÁé∞
```typescript
// src/app/[locale]/api/payments/create-intent/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { paymentService } from '@/libs/payments/core/payment-service';
import { validateAuth } from '@/libs/security/auth-middleware';

const CreatePaymentIntentSchema = z.object({
  amount: z.number().min(50), // ÊúÄÂ∞èÈáëÈ¢ù50ÂàÜ
  currency: z.string().length(3),
  description: z.string().optional(),
  paymentMethodTypes: z.array(z.string()).optional(),
  provider: z.string().optional()
});

export async function POST(request: NextRequest) {
  try {
    // 1. Ë∫´‰ªΩÈ™åËØÅ
    const user = await validateAuth(request);
    if (!user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 2. ËØ∑Ê±ÇÈ™åËØÅ
    const body = await request.json();
    const validatedData = CreatePaymentIntentSchema.parse(body);

    // 3. ÂàõÂª∫ÊîØ‰ªòÊÑèÂõæ
    const paymentIntent = await paymentService.createPaymentIntent({
      amount: validatedData.amount,
      currency: validatedData.currency,
      customerId: user.uid,
      description: validatedData.description,
      paymentMethodTypes: validatedData.paymentMethodTypes,
      metadata: {
        userId: user.uid,
        userEmail: user.email,
        source: 'web_app'
      }
    }, validatedData.provider);

    // 4. ËøîÂõûÂÆ¢Êà∑Á´ØÂØÜÈí•
    return NextResponse.json({
      clientSecret: paymentIntent.clientSecret,
      paymentIntentId: paymentIntent.id
    });
  } catch (error) {
    console.error('Create payment intent error:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request data', details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Payment intent creation failed' },
      { status: 500 }
    );
  }
}
```

### 5. WebhookÂ§ÑÁêÜ
```typescript
import { headers } from 'next/headers';
// src/app/[locale]/api/webhooks/stripe/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { paymentService } from '@/libs/payments/core/payment-service';

export async function POST(request: NextRequest) {
  try {
    // 1. Ëé∑ÂèñËØ∑Ê±Ç‰ΩìÂíåÁ≠æÂêç
    const body = await request.text();
    const headersList = headers();
    const signature = headersList.get('stripe-signature');

    if (!signature) {
      return NextResponse.json(
        { error: 'Missing stripe-signature header' },
        { status: 400 }
      );
    }

    // 2. Â§ÑÁêÜWebhook
    const result = await paymentService.processWebhook(
      'stripe',
      body,
      signature
    );

    // 3. ËøîÂõûÂ§ÑÁêÜÁªìÊûú
    return NextResponse.json({
      received: true,
      processed: result.processed,
      message: result.message
    });
  } catch (error) {
    console.error('Stripe webhook error:', error);

    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 400 }
    );
  }
}

// ÈÖçÁΩÆÔºöÁ¶ÅÁî®Next.jsÁöÑbodyËß£Êûê
export const config = {
  api: {
    bodyParser: false,
  },
};
```

### 6. ÂâçÁ´ØÊîØ‰ªòÁªÑ‰ª∂
```typescript
// src/components/payments/PaymentForm.tsx
'use client';

import { useState } from 'react';
import { loadStripe } from '@stripe/stripe-js';
import {
  Elements,
  PaymentElement,
  useStripe,
  useElements
} from '@stripe/react-stripe-js';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Env } from '@/libs/Env';

const stripePromise = loadStripe(Env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY);

interface PaymentFormProps {
  amount: number;
  currency: string;
  description?: string;
  onSuccess?: (paymentIntent: any) => void;
  onError?: (error: any) => void;
}

function PaymentFormContent({ amount, currency, description, onSuccess, onError }: PaymentFormProps) {
  const stripe = useStripe();
  const elements = useElements();
  const [isLoading, setIsLoading] = useState(false);
  const [clientSecret, setClientSecret] = useState<string | null>(null);

  // ÂàõÂª∫ÊîØ‰ªòÊÑèÂõæ
  const createPaymentIntent = async () => {
    try {
      const response = await fetch('/api/payments/create-intent', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          amount,
          currency,
          description
        })
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to create payment intent');
      }

      setClientSecret(data.clientSecret);
    } catch (error) {
      onError?.(error);
    }
  };

  // Â§ÑÁêÜÊîØ‰ªòÊèê‰∫§
  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();

    if (!stripe || !elements || !clientSecret) {
      return;
    }

    setIsLoading(true);

    try {
      const { error, paymentIntent } = await stripe.confirmPayment({
        elements,
        clientSecret,
        confirmParams: {
          return_url: `${window.location.origin}/payment/success`,
        },
        redirect: 'if_required'
      });

      if (error) {
        onError?.(error);
      } else if (paymentIntent?.status === 'succeeded') {
        onSuccess?.(paymentIntent);
      }
    } catch (error) {
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>ÊîØ‰ªò‰ø°ÊÅØ</CardTitle>
        <p className="text-sm text-muted-foreground">
          ÈáëÈ¢ù: {(amount / 100).toFixed(2)} {currency.toUpperCase()}
        </p>
        {description && (
          <p className="text-sm text-muted-foreground">{description}</p>
        )}
      </CardHeader>
      <CardContent>
        {!clientSecret ? (
          <Button onClick={createPaymentIntent} className="w-full">
            ÂºÄÂßãÊîØ‰ªò
          </Button>
        ) : (
          <form onSubmit={handleSubmit} className="space-y-4">
            <PaymentElement />
            <Button
              type="submit"
              disabled={!stripe || isLoading}
              className="w-full"
            >
              {isLoading ? 'Â§ÑÁêÜ‰∏≠...' : `ÊîØ‰ªò ${(amount / 100).toFixed(2)} ${currency.toUpperCase()}`}
            </Button>
          </form>
        )}
      </CardContent>
    </Card>
  );
}

export function PaymentForm(props: PaymentFormProps) {
  return (
    <Elements stripe={stripePromise}>
      <PaymentFormContent {...props} />
    </Elements>
  );
}
```

---

## üîí ÂÆâÂÖ®ÂíåÂêàËßÑ

### 1. PCI DSS ÂêàËßÑ
```typescript
// src/libs/payments/security/pci-compliance.ts
export class PCIDSSCompliance {
  // Á°Æ‰øù‰∏çÂ≠òÂÇ®ÊïèÊÑüÊîØ‰ªòÊï∞ÊçÆ
  static validatePaymentData(data: any): void {
    const forbiddenFields = [
      'card_number',
      'cvv',
      'cvc',
      'expiry_date',
      'card_holder_name'
    ];

    for (const field of forbiddenFields) {
      if (data[field]) {
        throw new SecurityError(`Á¶ÅÊ≠¢Â≠òÂÇ®ÊïèÊÑüÊîØ‰ªòÊï∞ÊçÆ: ${field}`);
      }
    }
  }

  // ÊîØ‰ªòÊï∞ÊçÆËÑ±Êïè
  static sanitizePaymentData(data: any): any {
    const sanitized = { ...data };

    // ËÑ±ÊïèÂç°Âè∑ÔºàÂè™‰øùÁïôÂêé4‰ΩçÔºâ
    if (sanitized.card_last4) {
      sanitized.card_display = `****-****-****-${sanitized.card_last4}`;
    }

    // ÁßªÈô§ÊïèÊÑüÂ≠óÊÆµ
    delete sanitized.card_number;
    delete sanitized.cvv;
    delete sanitized.cvc;

    return sanitized;
  }
}
```

### 2. Êï∞ÊçÆÂä†ÂØÜÂ≠òÂÇ®
```typescript
// src/libs/payments/storage/transaction-store.ts
import { PaymentEncryption } from '../security/payment-encryption';

export class TransactionStore {
  private encryption = new PaymentEncryption();

  async createTransaction(transaction: Transaction): Promise<void> {
    // 1. È™åËØÅÊï∞ÊçÆÂêàËßÑÊÄß
    PCIDSSCompliance.validatePaymentData(transaction);

    // 2. Âä†ÂØÜÊïèÊÑüÊï∞ÊçÆ
    const encryptedTransaction = await this.encryption.encryptSensitiveFields(transaction);

    // 3. Â≠òÂÇ®Âà∞Firestore
    await addDoc(collection(db, 'transactions'), {
      ...encryptedTransaction,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });

    // 4. ËÆ∞ÂΩïÂÆ°ËÆ°Êó•Âøó
    await this.auditLogger.log({
      type: 'TRANSACTION_CREATED',
      details: {
        transactionId: transaction.id,
        amount: transaction.amount,
        currency: transaction.currency,
        provider: transaction.provider
      },
      severity: 'info'
    });
  }
}
```

### 3. FirebaseÁî®Êà∑Êï∞ÊçÆÂêåÊ≠•
```typescript
// src/libs/firebase/user-payment-sync.ts
import { doc, getDoc, updateDoc } from 'firebase/firestore';
import { db } from '@/libs/firebase/config';

export class UserPaymentSync {
  // ÂêåÊ≠•ÊîØ‰ªòÂÆ¢Êà∑IDÂà∞FirebaseÁî®Êà∑ËÆ∞ÂΩï
  async syncCustomerId(userId: string, provider: string, customerId: string): Promise<void> {
    const userRef = doc(db, 'users', userId);

    await updateDoc(userRef, {
      [`paymentProviders.${provider}.customerId`]: customerId,
      [`paymentProviders.${provider}.createdAt`]: new Date(),
      [`paymentProviders.${provider}.status`]: 'active',
      updatedAt: new Date()
    });
  }

  // ÂêåÊ≠•ËÆ¢ÈòÖÁä∂ÊÄÅÂà∞Firebase
  async syncSubscriptionStatus(
    userId: string,
    subscriptionData: {
      subscriptionId: string;
      status: string;
      planId: string;
      currentPeriodEnd: Date;
      provider: string;
    }
  ): Promise<void> {
    const userRef = doc(db, 'users', userId);

    await updateDoc(userRef, {
      subscriptionPlan: subscriptionData.planId,
      subscriptionStatus: subscriptionData.status,
      subscriptionId: subscriptionData.subscriptionId,
      subscriptionProvider: subscriptionData.provider,
      subscriptionCurrentPeriodEnd: subscriptionData.currentPeriodEnd,
      updatedAt: new Date()
    });
  }

  // ÂêåÊ≠•ÊîØ‰ªòÂéÜÂè≤ËÆ∞ÂΩï
  async syncPaymentHistory(userId: string, paymentData: any): Promise<void> {
    const userRef = doc(db, 'users', userId);
    const userDoc = await getDoc(userRef);

    if (userDoc.exists()) {
      const currentHistory = userDoc.data().paymentHistory || [];
      const updatedHistory = [
        ...currentHistory,
        {
          ...paymentData,
          timestamp: new Date()
        }
      ].slice(-50); // Âè™‰øùÁïôÊúÄËøë50Êù°ËÆ∞ÂΩï

      await updateDoc(userRef, {
        paymentHistory: updatedHistory,
        lastPaymentAt: new Date(),
        updatedAt: new Date()
      });
    }
  }
}
```

---

## üìä ÁõëÊéßÂíåÂàÜÊûê

### 1. ÊîØ‰ªòÊåáÊ†áÁõëÊéß
```typescript
// src/libs/payments/monitoring/payment-metrics.ts
export class PaymentMetrics {
  // ÊîØ‰ªòÊàêÂäüÁéá
  async getPaymentSuccessRate(timeRange: TimeRange): Promise<number> {
    const totalPayments = await this.getPaymentCount(timeRange);
    const successfulPayments = await this.getSuccessfulPaymentCount(timeRange);

    return totalPayments > 0 ? (successfulPayments / totalPayments) * 100 : 0;
  }

  // Âπ≥ÂùáÊîØ‰ªòÈáëÈ¢ù
  async getAveragePaymentAmount(timeRange: TimeRange): Promise<number> {
    const payments = await this.getPayments(timeRange);
    const totalAmount = payments.reduce((sum, payment) => sum + payment.amount, 0);

    return payments.length > 0 ? totalAmount / payments.length : 0;
  }

  // ÊîØ‰ªòÊñπÂºèÂàÜÂ∏É
  async getPaymentMethodDistribution(timeRange: TimeRange): Promise<Record<string, number>> {
    const payments = await this.getPayments(timeRange);
    const distribution: Record<string, number> = {};

    payments.forEach((payment) => {
      const method = payment.paymentMethod || 'unknown';
      distribution[method] = (distribution[method] || 0) + 1;
    });

    return distribution;
  }

  // Êèê‰æõÂïÜÊÄßËÉΩÂØπÊØî
  async getProviderPerformance(timeRange: TimeRange): Promise<Record<string, ProviderMetrics>> {
    const payments = await this.getPayments(timeRange);
    const providerMetrics: Record<string, ProviderMetrics> = {};

    payments.forEach((payment) => {
      const provider = payment.provider;
      if (!providerMetrics[provider]) {
        providerMetrics[provider] = {
          totalPayments: 0,
          successfulPayments: 0,
          totalAmount: 0,
          averageProcessingTime: 0
        };
      }

      providerMetrics[provider].totalPayments++;
      if (payment.status === 'succeeded') {
        providerMetrics[provider].successfulPayments++;
      }
      providerMetrics[provider].totalAmount += payment.amount;
    });

    return providerMetrics;
  }
}
```

### 2. ÂÆûÊó∂ÂëäË≠¶Á≥ªÁªü
```typescript
// src/libs/payments/monitoring/payment-alerts.ts
export class PaymentAlerts {
  // ÊîØ‰ªòÂ§±Ë¥•ÁéáÂëäË≠¶
  async checkPaymentFailureRate(): Promise<void> {
    const last24Hours = {
      start: new Date(Date.now() - 24 * 60 * 60 * 1000),
      end: new Date()
    };

    const failureRate = await this.getPaymentFailureRate(last24Hours);

    if (failureRate > 5) { // Â§±Ë¥•ÁéáË∂ÖËøá5%
      await this.sendAlert({
        type: 'HIGH_PAYMENT_FAILURE_RATE',
        severity: 'warning',
        message: `ÊîØ‰ªòÂ§±Ë¥•ÁéáËøáÈ´ò: ${failureRate.toFixed(2)}%`,
        data: { failureRate, timeRange: last24Hours }
      });
    }
  }

  // ÂºÇÂ∏∏ÊîØ‰ªòÈáëÈ¢ùÂëäË≠¶
  async checkAnomalousPayments(): Promise<void> {
    const recentPayments = await this.getRecentPayments(100);
    const averageAmount = this.calculateAverage(recentPayments.map(p => p.amount));
    const threshold = averageAmount * 10; // 10ÂÄçÂπ≥ÂùáÈáëÈ¢ù

    const anomalousPayments = recentPayments.filter(p => p.amount > threshold);

    if (anomalousPayments.length > 0) {
      await this.sendAlert({
        type: 'ANOMALOUS_PAYMENT_AMOUNT',
        severity: 'critical',
        message: `Ê£ÄÊµãÂà∞ÂºÇÂ∏∏Â§ßÈ¢ùÊîØ‰ªò`,
        data: { payments: anomalousPayments, threshold }
      });
    }
  }

  // WebhookÂ§ÑÁêÜÂª∂ËøüÂëäË≠¶
  async checkWebhookProcessingDelay(): Promise<void> {
    const pendingWebhooks = await this.getPendingWebhooks();
    const delayThreshold = 5 * 60 * 1000; // 5ÂàÜÈíü

    const delayedWebhooks = pendingWebhooks.filter(
      webhook => Date.now() - webhook.receivedAt.getTime() > delayThreshold
    );

    if (delayedWebhooks.length > 0) {
      await this.sendAlert({
        type: 'WEBHOOK_PROCESSING_DELAY',
        severity: 'warning',
        message: `WebhookÂ§ÑÁêÜÂª∂Ëøü: ${delayedWebhooks.length}‰∏™‰∫ã‰ª∂`,
        data: { delayedWebhooks }
      });
    }
  }
}
```

---

## üöÄ ÈÉ®ÁΩ≤ÂíåÈÖçÁΩÆ

### 1. ÁéØÂ¢ÉÂèòÈáèÈÖçÁΩÆ
```bash
# .env.local
# Stripe ÈÖçÁΩÆ
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...

# ÊîØ‰ªòÁ≥ªÁªüÈÖçÁΩÆ
PAYMENT_DEFAULT_PROVIDER=stripe
PAYMENT_ENCRYPTION_KEY=your-encryption-key
PAYMENT_WEBHOOK_TIMEOUT=30000

# ÁõëÊéßÈÖçÁΩÆ
PAYMENT_ALERTS_ENABLED=true
PAYMENT_METRICS_RETENTION_DAYS=90

# ÂÆâÂÖ®ÈÖçÁΩÆ
PCI_COMPLIANCE_MODE=strict
PAYMENT_AUDIT_ENABLED=true
PAYMENT_DATA_RETENTION_DAYS=2555 # 7Âπ¥ÂêàËßÑË¶ÅÊ±Ç
```

### 2. ‰æùËµñÂåÖÂÆâË£Ö
```json
{
  "dependencies": {
    "stripe": "^17.4.0",
    "@stripe/stripe-js": "^4.10.0",
    "@stripe/react-stripe-js": "^2.10.0",
    "crypto-js": "^4.2.0",
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "@types/crypto-js": "^4.2.0"
  }
}
```

### 3. Stripe DashboardÈÖçÁΩÆ

#### WebhookÁ´ØÁÇπÈÖçÁΩÆ
Âú®Stripe Dashboard‰∏≠ÈÖçÁΩÆ‰ª•‰∏ãWebhook‰∫ã‰ª∂Ôºö
- `payment_intent.succeeded`
- `payment_intent.payment_failed`
- `customer.subscription.created`
- `customer.subscription.updated`
- `customer.subscription.deleted`
- `invoice.payment_succeeded`
- `invoice.payment_failed`

ÊâÄÊúâÊîØ‰ªòÁõ∏ÂÖ≥ API Â∫î‰ΩøÁî®ÂõΩÈôÖÂåñË∑ØÁî±:

```
//¬†Ê≠£Á°ÆÁöÑË∑ØÂæÑ
const¬†apiUrl¬†=¬†`/${locale}/api/payments/create-customer`;
```
**Webhook URL:** `https://yourdomain.com/api/webhooks/stripe`

#### APIÁâàÊú¨ÈîÅÂÆö
Á°Æ‰øùÂú®Stripe Dashboard‰∏≠Â∞ÜAPIÁâàÊú¨ËÆæÁΩÆ‰∏∫ `2025-06-30.basil`

---

## üìã ÂÆûÊñΩËÆ°Âàí

### Á¨¨‰∏ÄÈò∂ÊÆµÔºöÂü∫Á°ÄÊû∂ÊûÑÔºà1Âë®Ôºâ
1. **ÊîØ‰ªòÊäΩË±°Â±ÇËÆæËÆ°**
   - ÂÆö‰πâÊîØ‰ªòÊèê‰æõÂïÜÊé•Âè£
   - ÂÆûÁé∞Âü∫Á°ÄÁ±ªÂûãÂÆö‰πâ
   - ÂàõÂª∫ÈîôËØØÂ§ÑÁêÜÊú∫Âà∂

2. **StripeÈõÜÊàê**
   - ÂÆûÁé∞StripeÈÄÇÈÖçÂô®
   - ÈÖçÁΩÆAPIÂÆ¢Êà∑Á´Ø
   - ÊµãËØïÂü∫Á°ÄÂäüËÉΩ

### Á¨¨‰∫åÈò∂ÊÆµÔºöÊ†∏ÂøÉÂäüËÉΩÔºà2Âë®Ôºâ
1. **ÊîØ‰ªòÂ§ÑÁêÜ**
   - ÊîØ‰ªòÊÑèÂõæÂàõÂª∫
   - ÊîØ‰ªòÁ°ÆËÆ§ÊµÅÁ®ã
   - ÊîØ‰ªòÂèñÊ∂àÂ§ÑÁêÜ

2. **ËÆ¢ÈòÖÁÆ°ÁêÜ**
   - ËÆ¢ÈòÖÂàõÂª∫ÂíåÊõ¥Êñ∞
   - Ë¥¶ÂçïÂë®ÊúüÁÆ°ÁêÜ
   - ËÆ¢ÈòÖÂèñÊ∂àÊµÅÁ®ã

### Á¨¨‰∏âÈò∂ÊÆµÔºöWebhookÂíåÂêåÊ≠•Ôºà1Âë®Ôºâ
1. **WebhookÂ§ÑÁêÜ**
   - ‰∫ã‰ª∂È™åËØÅÂíåÂ§ÑÁêÜ
   - ÈáçÂ§çÂ§ÑÁêÜÈò≤Êä§
   - ÈîôËØØÈáçËØïÊú∫Âà∂

2. **Êï∞ÊçÆÂêåÊ≠•**
   - FirebaseÁî®Êà∑Êï∞ÊçÆÂêåÊ≠•
   - ÊîØ‰ªòÁä∂ÊÄÅÊõ¥Êñ∞
   - ËÆ¢ÈòÖÁä∂ÊÄÅÂêåÊ≠•

### Á¨¨ÂõõÈò∂ÊÆµÔºöÂÆâÂÖ®ÂíåÁõëÊéßÔºà1Âë®Ôºâ
1. **ÂÆâÂÖ®Â¢ûÂº∫**
   - PCI DSSÂêàËßÑÈ™åËØÅ
   - Êï∞ÊçÆÂä†ÂØÜÂÆûÁé∞
   - ÂÆ°ËÆ°Êó•ÂøóÂÆåÂñÑ

2. **ÁõëÊéßÁ≥ªÁªü**
   - ÊîØ‰ªòÊåáÊ†áÊî∂ÈõÜ
   - ÂÆûÊó∂ÂëäË≠¶ÈÖçÁΩÆ
   - ÊÄßËÉΩÁõëÊéß

### Á¨¨‰∫îÈò∂ÊÆµÔºöÊµãËØïÂíå‰ºòÂåñÔºà1Âë®Ôºâ
1. **ÂÖ®Èù¢ÊµãËØï**
   - ÂçïÂÖÉÊµãËØï
   - ÈõÜÊàêÊµãËØï
   - Á´ØÂà∞Á´ØÊµãËØï

2. **ÊÄßËÉΩ‰ºòÂåñ**
   - ÊîØ‰ªòÊµÅÁ®ã‰ºòÂåñ
   - ÁºìÂ≠òÁ≠ñÁï•ÂÆûÊñΩ
   - ÈîôËØØÂ§ÑÁêÜÂÆåÂñÑ

---

## üéØ ÊÄªÁªì

Ëøô‰∏™ÊîØ‰ªòÁ≥ªÁªüÈõÜÊàêÊñπÊ°àÂÖ∑Êúâ‰ª•‰∏ãÊ†∏ÂøÉ‰ºòÂäøÔºö

‚úÖ **ÂÆåÂÖ®Ëß£ËÄ¶** - ÊîØÊåÅÂ§öÊîØ‰ªòÊèê‰æõÂïÜÔºåÊòì‰∫éÊâ©Â±ï
‚úÖ **APIÁ®≥ÂÆö** - Âõ∫ÂÆöÁâàÊú¨ÈîÅÂÆöÔºåÂêëÂêéÂÖºÂÆπ
‚úÖ **ÂÆâÂÖ®ÂêàËßÑ** - PCI DSSÂêàËßÑÔºå‰ºÅ‰∏öÁ∫ßÂÆâÂÖ®
‚úÖ **ÁõëÊéßÂÆåÂñÑ** - ÂÆûÊó∂ÊåáÊ†áÔºåÊô∫ËÉΩÂëäË≠¶
‚úÖ **Êòì‰∫éÁª¥Êä§** - Ê∏ÖÊô∞Êû∂ÊûÑÔºåÊ†áÂáÜÂåñÊé•Âè£
‚úÖ **FirebaseÈõÜÊàê** - Êó†ÁºùÁî®Êà∑Êï∞ÊçÆÂêåÊ≠•
‚úÖ **Â§öÊèê‰æõÂïÜÊîØÊåÅ** - ÊîØÊåÅStripe„ÄÅPayPalÁ≠âÂ§öÁßçÊîØ‰ªòÊñπÂºè

**Âª∫ËÆÆÁ´ãÂç≥ÂºÄÂßãÁ¨¨‰∏ÄÈò∂ÊÆµÂÆûÊñΩÔºå‰∏∫ÊîØ‰ªòÁ≥ªÁªüÂª∫Á´ãÂùöÂÆûÁöÑÊäÄÊúØÂü∫Á°Ä„ÄÇ**

---

## üìö Áõ∏ÂÖ≥ÊñáÊ°£

- [FirebaseËÆ§ËØÅÈõÜÊàê](./firebase-auth-integration.md) - Áî®Êà∑ËÆ§ËØÅÂíåÊùÉÈôêÁÆ°ÁêÜ
- [Á≥ªÁªüÊû∂ÊûÑËÆæËÆ°](./system-architecture.md) - Êï¥‰ΩìÁ≥ªÁªüÊû∂ÊûÑ
- [ÂÆûÊñΩË∑ØÁ∫øÂõæ](./implementation-roadmap.md) - È°πÁõÆÂÆûÊñΩËÆ°Âàí
- [ÂÆâÂÖ®ÂêàËßÑÊåáÂçó](./security-compliance.md) - ÂÆâÂÖ®ÂíåÂêàËßÑË¶ÅÊ±Ç
